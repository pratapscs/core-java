package com.corejava.SerializationDeserialization;

public class SerializationDeserialization 
{
	/* 
	 * 
	 * 
	 * 
	 * 3.Difference between Externalizable and Serialization interface ?
	 *                                  SERIALIZABLE                      EXTERNALIZABLE
	 * 
	 * Methods                     It is a marker interface it        It’s not a marker interface.
	 *                              doesn’t have any method.           It has method’s called writeExternal() 
	 *                                                                 and readExternal() 
	 *                                                     
	 * Default                      YES, Serializable provides its ,   NO, we need to override writeExternal() and readExternal() for serialization process to happen. 
	 * Serialization process        own default serialization process 
	 *                              we just need to implement 
	 *                              Serializable interface.            
	 *                              
	 *                              
	 *                              
	 *                              
	 *                              
	 *                              
	 *                              
	 *                              
	 *                              
	 *                              
	 *                              
	 * 4.How can you customize Serialization and DeSerialization process when you 
	 * have implemented Serializable interface?
	 * SerializeEmployee.java
	 * 
	 * 5.Wap to explain how can we Serialize and DeSerialize object by implementing 
	 * Externalizable interface?
	 * For Serialization process override writeExternal()  method & for 
	 * DeSerialization process by override readExternal() method.    
	 *  SerializeEmployee1.java    DeSerializeEmployee.java       
	 *  
	 * 6.How can you avoid certain member variables of class from getting 
	 * Serialized?
	 * Mark member variables as static or transient, and those member 
	 * variables will no more be a part of Serialization.
	 * 
	 * 7.What is serialVersionUID?
	 * The serialization at runtime associates with each serializable class a 
	 * version number, called a serialVersionUID, 
	 * which is used during deserialization to verify that the sender and receiver 
	 * of a serialized object have loaded classes for that object that are 
	 * compatible with respect to serialization.
	 * 
	 * 
	 * 
	 * 8. What will be impact of not defining serialVersionUID in class?
	 * serialVersionUID is used for version control of object.
	 * If we  don’t define serialVersionUID in the class, and any modification 
	 * is made in class, then we won’t be able to deSerialize our class because 
	 * serialVersionUID generated by java compiler for modified class will be
	 * different from old serialized object. And deserialization process will 
	 * end up throwing java.io.InvalidClassException  (because of serialVersionUID 
	 * mismatch) 
	 * SerializeEmployee2.java   DeSerializeEmployee1.java
	 * SerializeEmployee.java    DeSerializeEmployee1.java
	 * 
	 * 
	 *9.How can subclass avoid Serialization if its superClass has implemented 
	 *Serialization interface?
	 *If superClass has implemented Serializable that means subclass is also 
	 *Serializable (as subclass always inherits all features from its parent class)
	 *for avoiding Serialization in sub-class we can define writeObject() method 
	 *and throw NotSerializableException() from there as done below.
	 *SerializeDeserialize.java
	 *
	 *
	 *10.Can you Serialize Singleton class such that object returned by 
	 *Deserialization process  is in same state as it was during Serialization 
	 *time (regardless of any change made to it after Serialization) 
	 *YES, we can Serialize Singleton class such that object returned by 
	 *Deserialization process is in same state as it was during Serialization 
	 *time (regardless of any change made to it after Serialization)
	 *SingletonClass.java
	 *
	 * 
	 * 11.How you can avoid Deserialization process creating another instance 
	 * of Singleton class?
	 * We can simply use readResove() method to return same instance of class,
	 * rather than creating a new one.
	 * SingletonClass1.java
	 * 
	 * 
	 * 12.Are primitive types part of serialization process? 
	 * yes,primitive types part of serialization process
	 * SerializePrimitiveTypes.java
	 * 
	 * 
	 * 13.Is constructor of super class called during DeSerialization process 
	 * of subclass?
	 * It is depends on whether our superclass has implemented Serializable 
	 * or not.
	 * If superclass has implemented Serializable - constructor is not called 
	 * during DeSerialization process.
	 * If superclass has not implemented Serializable - constructor is called 
	 * during DeSerialization process.
	 * SerializeDeser1.java
	 * 
	 * 
	 * 14.What will happen if one the member of class does not implement 
	 * Serializable interface?
	 * If any of the member does not implement Serializable than  
	 * NotSerializableException is thrown. 
	 * 
	 * 
	 * 15.Why static member variables are not part of java serialization process?
	 * Serialization is applicable on objects or primitive data types only, but 
	 * static members are class level variables, therefore, different object’s of
	 * same class have same value for static member. 
	 *  So, serializing static member will consume unnecessary space and time.
	 *  Also, if modification is made in static member by any of the object, 
	 *  it won’t be in sync with other serialized object’s value.
	 *  
	 *  
	 * 16.What is significance of transient variables?
	 * Serialization is not applicable on transient variables (it helps in saving 
	 * time and space during Serialization process), we must mark all rarely 
	 * used variables as transient. We can initialize transient variables during 
	 * deSerialization by customizing deSerialization process.


	 * 
	 * 
	 * 
	 * 
	 * 
	 *  
	 */

}
